"""
Лабораторная работа №4
С клавиатуры вводится два числа K и N.
Квадратная матрица А(N,N), состоящая из 4-х равных по размерам подматриц, B,C,D,E заполняется случайным образом целыми числами в интервале [-10,10].
Для отладки использовать не случайное заполнение, а целенаправленное.

Для ИСТд-12 вид матрицы А
Е	В
D	С

Для простоты все индексы в подматрицах относительные.
По сформированной матрице F (или ее частям) необходимо вывести не менее 3 разных графиков.
Программа должна использовать функции библиотек numpy  и mathplotlib

8.	Формируется матрица F следующим образом: скопировать в нее А и если в С количество простых чисел в нечетных столбцах,
чем количество нулевых  элементов в четных строках, то поменять местами Е и С симметрично, иначе С и В поменять местами несимметрично.
При этом матрица А не меняется. После чего если определитель матрицы А больше суммы диагональных элементов матрицы F,
то вычисляется выражение: A-1*AT – K * F, иначе вычисляется выражение (AТ +G-1-F-1)*K, где G-нижняя треугольная матрица, полученная из А.
Выводятся по мере формирования А, F и все матричные операции последовательно.
"""
import numpy as np
import matplotlib.pyplot as plt

K = int(input("Введите число K: "))

# Ввод размера матрицы с клавиатуры
while True:
    N = int(input("Введите размер/ранг матрицы (N): "))
    if N >= 6 and N % 2 == 0:
        break
    else:
        print(
            "Пожалуйста, введите размер/ранг матрицы (N) число больше/равно 6 и четное число для равных по размеру подматриц")

A = np.random.randint(-10, 11, (N, N))

E = [row[:N // 2] for row in A[:N // 2]]
B = [row[N // 2:] for row in A[:N // 2]]
D = [row[:N // 2] for row in A[N // 2:]]
C = [row[N // 2:] for row in A[N // 2:]]


# Определение функции для проверки на простое число
def is_prime(num):
    count = 0
    for k in range(2, num):
        if num % k == 0 or num % 2 == 0:
            count = count
        else:
            if num % 3 == 0 and num // 3 != 1:
                count = 0
            else:
                count += 1
                break
    return count


# Считаем количество простых чисел в нечётных столбцах матрицы С и нулей в чётных строках
prime_count = 0
zero_count = 0
for i in range(len(C)):
    for j in range(len(C)):
        if j % 2 != 0:
            prime_count += np.count_nonzero(is_prime(C[i][j]))
        if i % 2 == 0:
            zero_count += np.count_nonzero(C[i][j] == 0)

# Создаем копию матрицы A для F
F = np.copy(A)

# Проверяем условие и меняем матрицы B и C местами или E и C симметрично
if prime_count > zero_count:
    F[N//2:, :N//2], F[N//2:, N//2:] = F[N//2:, N//2:], F[N//2:, :N//2]
else:
    F[N//2:, N//2:], F[N//2:, :N//2] = F[N//2:, :N//2], F[N//2:, N//2:]

# Проверяем условие определителя матрицы А и вычисляем выражение
det_A = np.linalg.det(A)
sum_diag_F = np.trace(F)
G = np.tril(A)

if det_A > sum_diag_F:
    result = (np.linalg.inv(A) * np.transpose(A)) - (K * F)
else:
    result = ((np.linalg.inv(A) + np.linalg.inv(G)) - np.linalg.inv(F)) * K

# Вывод результатов
print("Матрица A:")
print(A)

print("\nМатрица F:")
print(F)

print("\nРезультат вычислений:")
print(result)

# Визуализация данных из матрицы F в виде графиков
for i in range(N):
    plt.plot(F[i], label=f'Row {i + 1}')
plt.legend()
plt.title('Графики данных из матрицы F')
plt.xlabel('Столбцы')
plt.ylabel('Значения')
plt.show()

#2 график
plt.plot(prime_count, marker='s')
plt.title("График количества простых чисел в нечетных столбцах матрицы F")
plt.ylabel('Количество простых чисел')
plt.grid(True)
plt.show()

#3 график
plt.plot(zero_count, marker='s')
plt.title("График количества нулей в четных строках матрицы F")
plt.ylabel('Количество простых чисел')
plt.grid(True)
plt.show()
